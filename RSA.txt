Schlüsselstärken verlieren ab einer bestimmten Grenze an Wert. Wenn sie mit gegenwärtig existierenden sowie voraussichtlich zukünftig entwickelten Technologien nicht mehr gebrochen werden können, sind sie an dieser Grenze angelangt. Diese Aussage schließt dabei Quantencomputer aus, da diese durch ihre Effizienz im Lösen von bestimmten Rechenaufgaben viele Signierverfahren komplett obsolet machen.

Grenze von Schlüsselsicherheit abgesichert durch abflauen von mooreschen Gesetz?



RSA mathematisch

RSA ist ein asymmetrisches Kryptographieverfahren, welches 1978 von Ronald Rivest, Adi Shamir und Leonard Adleman veröffentlicht wurde. Aus ihren Nachnamen erschließt sich hierbei auch der Name des Verfahrens "RSA".
Für dieses Verfahren werden ein public-key und ein private-key generiert. Der public-key besteht dabei aus dem RSA-Modul n sowie dem Verschlüsselungsexponenten e. Der private-key enthält ebenfalls n und den Entschlüsselungsexponenten d.
Die Namen der Exponenten scheinen unsinnig, da beim Signieren der private-key verwendet wird. Dies hat den Grund, dass das Signieren die Operationen des Verschlüsselns einer Nachricht in umgekehrter Reihenfolge durchführt. So wird 
beim Verschlüsseln mit dem public-key agiert. Für das Erstellen der Schlüssel werden zunächst zwei große zufällige Primzahlen p und q generiert, für welche p ungleich q gilt. Der RSA-Modul n lässt sich nun als n = p * q berechnen. Außerdem wird phi von n = (p-1)*(q-1) berechnet.
Phi meint die Eulersche Phi-Funktion, welche einer natürlichen Zahl n die Anzahl natürlicher Zahlen von 1 bis n, welche zu n teilerfremd sind zuordnet. Hierbei handelt es sich um einen Spezialfall, da p und q Primzahlen sind. Somit wäre q zu den Zahlen von 1 bis q-1 teilerfremd und phi von q
lässt sich als q-1 darstellen. Wird dies auch bei p angewandt ergibt sich für phi von n die oben genannte Definition phi von n = (p-1) * (q-1). Danach wird der Verschlüsselungsexponent e so gewählt, dass e Teil der natürlichen Zahlen ist, 1 < e < phi von n gilt und dass e und phi von n teilerfremd
sind. Der public-key ist somit berechnet und lässt sich als Tupel (n, e) darstellen. Für den private-key fehlt nun noch der Entschlüsselungsexponent d, welcher sich aus e*d = 1 (mod phi von n) berechnen lässt, vorausgesetzt d ist Teil der natürlichen Zahlen und es erfüllt die Vorgabe 1 < d < phi von n.
Der private-key (n, d) ist einsatzbereit, nun sollten sicherheitshalber p, q und phi von n gelöscht werden um mögliche Spuren von public und private-key zu verwischen. Eine Nachricht m soll nun signiert werden. Zunächst wird ein Hash der Nachricht erstellt, da so die Größe der Nachricht keinen
Einfluss auf die Dauer des Signierens hat. Die Signatur s berechnet sich nun als s = Hash(m) hoch d mod n und kann zusammen mit dem public-key und der eigentlichen Nachricht dem Empfänger übermittelt werden. Der Empfänger berechnet nun v = s hoch e mod n und ermittelt selbst Hash(m) der
originalen Nachricht. Stimmen v und Hash(m) überein besteht eine sehr hohe Chance, dass die Nachricht echt ist. Ihre Integrität und Authentizität sind sichergestellt. Die Sicherheit des RSA Verfahrens ist durch die Unkenntnis von phi von n gegeben, so kann der Angreifer nicht einfach
den private-key reproduzieren. Phi von n lässt sich mit dem Wissen um  p und q über den vorher gezeigten Speziallfall einfach berechnen, ist jedoch ohne diese extrem Zeitaufwendig und unsinnig für einen Angreifer. Seine größte Chance liegt im Faktorisieren von n in p und q, hierfür sind jedoch auch
noch keine effizienten Algorithmen bekannt. Dies nennt man auch eine Einwegfunktion, da die Berechnungen nur in eine Richtung einfach durchzuführen sind. 


The public key in this cryptosystem consists of the value n, which is called the modulus,
and the value e, which is called the public exponent. The private key consists of the
modulus n and the value d, which is called the private exponent.
An RSA public-key / private-key pair can be generated by the following steps:
1. Generate a pair of large, random primes p and q.
2. Compute the modulus n as n = pq.
3. Select an odd public exponent e between 3 and n-1 that is relatively prime to p-1
and q-1.
4. Compute the private exponent d from e, p and q. (See below.)
5. Output (n, e) as the public key and (n, d) as the private key.
The encryption operation in the RSA cryptosystem is exponentiation to the eth power
modulo n:
c = ENCRYPT (m) = me mod n .
The input m is the message; the output c is the resulting ciphertext. In practice, the
message m is typically some kind of appropriately formatted key to be shared. The actual
message is encrypted with the shared key using a traditional encryption algorithm. This
construction makes it possible to encrypt a message of any length with only one
exponentiation.
The decryption operation is exponentiation to the dth power modulo n:
m = DECRYPT (c) = c d mod n .
THE M ATHEMATICS OF THE RSA PUBLIC-KEY CRYPTOSYSTEM Page 6
The relationship between the exponents e and d ensures that encryption and decryption
are inverses, so that the decryption operation recovers the original message m. Without
the private key (n, d) (or equivalently the prime factors p and q), it’s difficult (by
CONJECTURE 6) to recover m from c. Consequently, n and e can be made public without
compromising security, which is the basic requirement for a public-key cryptosystem.
The fact that the encryption and decryption operations are inverses and operate on the
same set of inputs also means that the operations can be employed in reverse order to
obtain a digital signature scheme following Diffie and Hellman’s model. A message can
be digitally signed by applying the decryption operation to it, i.e., by exponentiating it to
the dth power:
s = SIGN (m) = md mod n .
The digital signature can then be verified by applying the encryption operation to it and
comparing the result with and/or recovering the message:
m = VERIFY (s) = s e mod n .
In practice, the plaintext m is generally some function of the message, for instance a
formatted one-way hash of the message. This makes it possible to sign a message of any
length with only one exponentiation

https://www.nku.edu/~christensen/the%20mathematics%20of%20the%20RSA%20cryptosystem.pdf ///// dohmen

Ed mathem

EdDSA and Ed25519
EdDSA (Edwards-curve Digital Signature Algorithm) is a modern and secure digital signature algorithm based on performance-optimized elliptic curves, such as the 255-bit curve  and the 448-bit curve . The EdDSA signatures use the Edwards form of the elliptic curves (for performance reasons), respectively edwards25519 and edwards448. The EdDSA algorithm is based on the 
 and relies on the difficulty of the ECDLP problem.
The EdDSA signature algorithm and its variants Ed25519 and Ed448 are technically described in the 
.
EdDSA Key Generation
Ed25519 and Ed448 use small private keys (32 or 57 bytes respectively), small public keys (32 or 57 bytes) and small signatures (64 or 114 bytes) with high security level at the same time (128-bit or 224-bit respectively).
Assume the elliptic curve for the EdDSA algorithm comes with a generator point G and a subgroup order q for the EC points, generated from G.
The EdDSA key-pair consists of:
private key (integer): privKey

    public key (EC point): pubKey = privKey * G

The private key is generated from a random integer, known as seed (which should have similar bit length, like the curve order). The seed is first hashed, then the last few bits, corresponding to the curve cofactor (8 for Ed25519 and 4 for X448) are cleared, then the highest bit is cleared and the second highest bit is set. These transformations guarantee that the private key will always belong to the same subgroup of EC points on the curve and that the private keys will always have similar bit length (to protect from timing-based side-channel attacks). For Ed25519 the private key is 32 bytes. For Ed448 the private key is 57 bytes.
The public key pubKey is a point on the elliptic curve, calculated by the EC point multiplication: pubKey = privKey * G (the private key, multiplied by the generator point G for the curve). The public key is encoded as compressed EC point: the y-coordinate, combined with the lowest bit (the parity) of the x-coordinate. For Ed25519 the public key is 32 bytes. For Ed448 the public key is 57 bytes.
EdDSA Sign
The EdDSA signing algorithm (
) takes as input a text message msg + the signer's EdDSA private key privKey and produces as output a pair of integers {R, s}. EdDSA signing works as follows (with minor simplifications):
EdDSA_sign(msg, privKey) --> { R, s }
Calculate pubKey = privKey * G
Deterministically generate a secret integer r = hash(hash(privKey) + msg) mod q (this is a bit simplified)
Calculate the public key point behind r by multiplying it by the curve generator: R = r * G
Calculate h = hash(R + pubKey + msg) mod q
Calculate s = (r + h * privKey) mod q

    Return the signature { R, s }

The produced digital signature is 64 bytes (32 + 32 bytes) for Ed25519 and 114 bytes (57 + 57 bytes) for Ed448. It holds a compressed point R + the integer s (confirming that the signer knows the msg and the privKey).
EdDSA Verify Signature
The EdDSA signature verification algorithm (
) takes as input a text message msg + the signer's EdDSA public key pubKey + the EdDSA signature {R, s} and produces as output a boolean value (valid or invalid signature). EdDSA verification works as follows (with minor simplifications):
EdDSA_signature_verify(msg, pubKey, signature { R, s } ) --> valid / invalid
Calculate h = hash(R + pubKey + msg) mod q
Calculate P1 = s * G
Calculate P2 = R + h * pubKey

    Return P1 == P2

How Does it Work?
During the verification the point P1 is calculated as: P1 = s * G.
During the signing s = (r + h * privKey) mod q. Now replace s in the above equation:

    P1 = s * G = (r + h * privKey) mod q * G = r * G + h * privKey * G = R + h * pubKey

The above is exactly the other point P2. If these points P1 and P2 are the same EC point, this proves that the point P1, calculated by the private key matches the point P2, created by its corresponding public key.
ECDSA vs EdDSA
If we compare the signing and verification for EdDSA, we shall find that EdDSA is simpler than ECDSA, easier to understand and to implement. Both signature algorithms have similar security strength for curves with similar key lengths. For the most popular curves (liked edwards25519 and edwards448) the EdDSA algorithm is slightly faster than ECDSA, but this highly depends on the curves used and on the certain implementation. Unlike ECDSA the EdDSA signatures do not provide a way to recover the signer's public key from the signature and the message. Generally, it is considered that EdDSA is recommended for most modern apps.

https://cryptobook.nakov.com/digital-signatures/eddsa-and-ed25519

RSA vs Ed25519 Theorie
Sicherheit ab einem gewissen Level Gleich
RSA 3072 Bit Key vs Ed25519 Key - in Ed25519 Paper als gleichwertig betitelt 
Ed25519 schneller

Screenshot Nachweis RSA Zeit vs Ed25519 Zeit auf ICS Mini 2

.GPG Datei könnte jemand MITM mit selbem Namen mitgeben -> würde trotzdem als richtig erkann werden
Lösungsvorschlag: Key mit Iseg Kennung / spezielle Mail erstellen
GPG --verify Output mit grep nach spezieller Iseg Mail durchsuchen -- dementsprechend handeln

ed25519 vs ed448 
ed448 theoretisch sicherer, vor quantencomputer genauso wertlos, da beide dadurch in einenm hinnehmbaren rahmen knackbar wären.
ed448 braucht neueres gpg, müsste noch installiert werden zum ausprobieren

icsupdate.sh vorstellen
-Screenshot von getoptarg bis verifizieren

-Updateprozess vorstellen -> 
Der für diese Arbeit wichtige Part ist der start des eigentlichen Updates
Variablendeklaration
update und update Verifiziertdatei müssen im ZIP FILE PATH liegen.
Vorstellung Parameter
neu hinzu S und C
S - GPG
C - C
existiert Zip File?
ist es eine kombinierte Datei aus Update und Signatur (NUR .gpg)?? -> Decrypt
ist es eine gpg signatur -S -> verifizieren
ist es eine C 	signatur -C -> verifizieren
return 1 == abbruch update
return 0 == grünes licht
ohne signatur geht auch

erkenntlich machen, welcher code aus dem icsupdate.sh von mir stammt

weiße Seiten in Latex:
1. zu Beginn alles auf neuer Buchseite
2. Chapter können nur auf ungerade Seite anfangen

neues image wird geöffnet und neue icsupdate.sh gelesen
Da ein aktuelles icsupdate.sh gestartet wird, kann das nächste Update noch nicht mit Verifizierprozess stattfinden, da dem neuen icsupdate.sh diesselben parameter mitgegeben werden, wie dem aktuellen. Jedoch würde nur die neue icsupdate.sh die Parameter zum verifizieren verstehen, da sie nur da definiert sind. Die aktuelle icsupdate.sh würde sofort mit error returnen.
